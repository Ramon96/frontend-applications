{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar AllowedEvents;\n\n(function (AllowedEvents) {\n  AllowedEvents[\"redraw\"] = \"redraw\";\n  AllowedEvents[\"fill\"] = \"fill\";\n  AllowedEvents[\"mouseup\"] = \"mouseup\";\n  AllowedEvents[\"mousedown\"] = \"mousedown\";\n  AllowedEvents[\"mouseenter\"] = \"mouseenter\";\n  AllowedEvents[\"mouseleave\"] = \"mouseleave\";\n})(AllowedEvents = exports.AllowedEvents || (exports.AllowedEvents = {}));\n\nvar CanvasFreeDrawing =\n/** @class */\nfunction () {\n  function CanvasFreeDrawing(params) {\n    var elementId = params.elementId,\n        width = params.width,\n        height = params.height,\n        _a = params.backgroundColor,\n        backgroundColor = _a === void 0 ? [255, 255, 255] : _a,\n        _b = params.lineWidth,\n        lineWidth = _b === void 0 ? 5 : _b,\n        _c = params.strokeColor,\n        strokeColor = _c === void 0 ? [0, 0, 0] : _c,\n        disabled = params.disabled,\n        _d = params.showWarnings,\n        showWarnings = _d === void 0 ? false : _d,\n        _e = params.maxSnapshots,\n        maxSnapshots = _e === void 0 ? 10 : _e;\n    this.requiredParam(params, 'elementId');\n    this.requiredParam(params, 'width');\n    this.requiredParam(params, 'height');\n    this.elementId = elementId;\n    this.canvasNode = document.getElementById(this.elementId);\n\n    if (this.canvasNode instanceof HTMLCanvasElement) {\n      this.canvas = this.canvasNode;\n    } else if (this.canvasNode instanceof HTMLElement) {\n      var newCanvas = document.createElement('canvas');\n      this.canvasNode.appendChild(newCanvas);\n      this.canvas = newCanvas;\n    } else {\n      throw new Error(\"No element found with following id: \" + this.elementId);\n    }\n\n    this.context = this.canvas.getContext('2d');\n    this.width = width;\n    this.height = height;\n    this.maxSnapshots = maxSnapshots;\n    this.snapshots = [];\n    this.undos = [];\n    this.positions = [];\n    this.leftCanvasDrawing = false; // to check if user left the canvas drawing, on mouseover resume drawing\n\n    this.isDrawing = false;\n    this.isDrawingModeEnabled = true;\n    this.imageRestored = false;\n    this.lineWidth = lineWidth;\n    this.strokeColor = this.toValidColor(strokeColor);\n    this.bucketToolColor = this.toValidColor(strokeColor);\n    this.bucketToolTolerance = 0;\n    this.isBucketToolEnabled = false;\n    this.listenersList = ['mouseDown', 'mouseMove', 'mouseLeave', 'mouseUp', 'touchStart', 'touchMove', 'touchEnd'];\n    this.allowedEvents = this.getAllowedEvents();\n    this.redrawCounter = 0;\n    this.dispatchEventsOnceEvery = 0; // this may become something like: [{event, counter}]\n    // initialize events\n\n    this.events = {\n      redrawEvent: new Event('cfd_redraw'),\n      fillEvent: new Event('cfd_fill'),\n      mouseUpEvent: new Event('cfd_mouseup'),\n      mouseDownEvent: new Event('cfd_mousedown'),\n      mouseEnterEvent: new Event('cfd_mouseenter'),\n      mouseLeaveEvent: new Event('cfd_mouseleave'),\n      touchStartEvent: new Event('cfd_touchstart'),\n      touchEndEvent: new Event('cfd_touchend')\n    };\n    this.bindings = {\n      mouseDown: this.mouseDown.bind(this),\n      mouseMove: this.mouseMove.bind(this),\n      mouseLeave: this.mouseLeave.bind(this),\n      mouseUp: this.mouseUp.bind(this),\n      mouseUpDocument: this.mouseUpDocument.bind(this),\n      touchStart: this.touchStart.bind(this),\n      touchMove: this.touchMove.bind(this),\n      touchEnd: this.touchEnd.bind(this)\n    };\n    this.touchIdentifier = undefined;\n    this.previousX = undefined;\n    this.previousY = undefined;\n    this.showWarnings = showWarnings; // cache\n\n    this.isNodeColorEqualCache = {};\n    this.setDimensions();\n    this.setBackground(backgroundColor);\n    this.storeSnapshot();\n    if (!disabled) this.enableDrawingMode();\n  }\n\n  CanvasFreeDrawing.prototype.requiredParam = function (object, param) {\n    if (!object || !object[param]) {\n      throw new Error(param + \" is required\");\n    }\n  };\n\n  CanvasFreeDrawing.prototype.logWarning = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    if (this.showWarnings) console.warn.apply(console, args);\n  };\n\n  CanvasFreeDrawing.prototype.addListeners = function () {\n    var _this = this;\n\n    this.listenersList.forEach(function (event) {\n      _this.canvas.addEventListener(event.toLowerCase(), _this.bindings[event]);\n    });\n    document.addEventListener('mouseup', this.bindings.mouseUpDocument);\n  };\n\n  CanvasFreeDrawing.prototype.removeListeners = function () {\n    var _this = this;\n\n    this.listenersList.forEach(function (event) {\n      _this.canvas.removeEventListener(event.toLowerCase(), _this.bindings[event]);\n    });\n    document.removeEventListener('mouseup', this.bindings.mouseUpDocument);\n  };\n\n  CanvasFreeDrawing.prototype.getAllowedEvents = function () {\n    var events = [];\n\n    for (var event_1 in AllowedEvents) {\n      events.push(event_1);\n    }\n\n    return events;\n  };\n\n  CanvasFreeDrawing.prototype.enableDrawingMode = function () {\n    this.isDrawingModeEnabled = true;\n    this.addListeners();\n    this.toggleCursor();\n    return this.isDrawingModeEnabled;\n  };\n\n  CanvasFreeDrawing.prototype.disableDrawingMode = function () {\n    this.isDrawingModeEnabled = false;\n    this.removeListeners();\n    this.toggleCursor();\n    return this.isDrawingModeEnabled;\n  };\n\n  CanvasFreeDrawing.prototype.mouseDown = function (event) {\n    if (event.button !== 0) return;\n    var x = event.pageX - this.canvas.offsetLeft;\n    var y = event.pageY - this.canvas.offsetTop;\n    this.drawPoint(x, y);\n  };\n\n  CanvasFreeDrawing.prototype.mouseMove = function (event) {\n    var x = event.pageX - this.canvas.offsetLeft;\n    var y = event.pageY - this.canvas.offsetTop;\n    this.drawLine(x, y, event);\n  };\n\n  CanvasFreeDrawing.prototype.touchStart = function (event) {\n    if (event.changedTouches.length > 0) {\n      var _a = event.changedTouches[0],\n          pageX = _a.pageX,\n          pageY = _a.pageY,\n          identifier = _a.identifier;\n      var x = pageX - this.canvas.offsetLeft;\n      var y = pageY - this.canvas.offsetTop;\n      this.touchIdentifier = identifier;\n      this.drawPoint(x, y);\n    }\n  };\n\n  CanvasFreeDrawing.prototype.touchMove = function (event) {\n    if (event.changedTouches.length > 0) {\n      var _a = event.changedTouches[0],\n          pageX = _a.pageX,\n          pageY = _a.pageY,\n          identifier = _a.identifier;\n      var x = pageX - this.canvas.offsetLeft;\n      var y = pageY - this.canvas.offsetTop; // check if is multi touch, if it is do nothing\n\n      if (identifier != this.touchIdentifier) return;\n      this.previousX = x;\n      this.previousY = y;\n      this.drawLine(x, y, event);\n    }\n  };\n\n  CanvasFreeDrawing.prototype.touchEnd = function () {\n    this.handleEndDrawing();\n    this.canvas.dispatchEvent(this.events.touchEndEvent);\n  };\n\n  CanvasFreeDrawing.prototype.mouseUp = function () {\n    this.handleEndDrawing();\n    this.canvas.dispatchEvent(this.events.mouseUpEvent);\n  };\n\n  CanvasFreeDrawing.prototype.mouseUpDocument = function () {\n    this.leftCanvasDrawing = false;\n  };\n\n  CanvasFreeDrawing.prototype.mouseLeave = function () {\n    if (this.isDrawing) this.leftCanvasDrawing = true;\n    this.isDrawing = false;\n    this.canvas.dispatchEvent(this.events.mouseLeaveEvent);\n  };\n\n  CanvasFreeDrawing.prototype.mouseEnter = function () {\n    this.canvas.dispatchEvent(this.events.mouseEnterEvent);\n  };\n\n  CanvasFreeDrawing.prototype.handleEndDrawing = function () {\n    this.isDrawing = false;\n    this.storeSnapshot();\n  };\n\n  CanvasFreeDrawing.prototype.drawPoint = function (x, y) {\n    if (this.isBucketToolEnabled) {\n      this.fill(x, y, this.bucketToolColor, {\n        tolerance: this.bucketToolTolerance\n      });\n    } else {\n      this.isDrawing = true;\n      this.storeDrawing(x, y, false);\n      this.canvas.dispatchEvent(this.events.mouseDownEvent);\n      this.handleDrawing();\n    }\n  };\n\n  CanvasFreeDrawing.prototype.drawLine = function (x, y, event) {\n    if (this.leftCanvasDrawing) {\n      this.leftCanvasDrawing = false;\n\n      if (event instanceof MouseEvent) {\n        this.mouseDown(event);\n      } else if (event instanceof TouchEvent) {\n        this.touchEnd();\n      }\n    }\n\n    if (this.isDrawing) {\n      this.storeDrawing(x, y, true);\n      this.handleDrawing(this.dispatchEventsOnceEvery);\n    }\n  };\n\n  CanvasFreeDrawing.prototype.handleDrawing = function (dispatchEventsOnceEvery) {\n    var _this = this;\n\n    this.context.lineJoin = 'round';\n    var positions = [this.positions.slice().pop()];\n    positions.forEach(function (position) {\n      if (position && position[0] && position[0].strokeColor) {\n        _this.context.strokeStyle = _this.rgbaFromArray(position[0].strokeColor);\n        _this.context.lineWidth = position[0].lineWidth;\n\n        _this.draw(position);\n      }\n    });\n\n    if (!dispatchEventsOnceEvery) {\n      this.canvas.dispatchEvent(this.events.redrawEvent);\n    } else if (this.redrawCounter % dispatchEventsOnceEvery === 0) {\n      this.canvas.dispatchEvent(this.events.redrawEvent);\n    }\n\n    this.undos = [];\n    this.redrawCounter += 1;\n  };\n\n  CanvasFreeDrawing.prototype.draw = function (position) {\n    var _this = this;\n\n    position.forEach(function (_a, i) {\n      var x = _a.x,\n          y = _a.y,\n          moving = _a.moving;\n\n      _this.context.beginPath();\n\n      if (moving && i) {\n        _this.context.moveTo(position[i - 1]['x'], position[i - 1]['y']);\n      } else {\n        _this.context.moveTo(x - 1, y);\n      }\n\n      _this.context.lineTo(x, y);\n\n      _this.context.closePath();\n\n      _this.context.stroke();\n    });\n  }; // https://en.wikipedia.org/wiki/Flood_fill\n\n\n  CanvasFreeDrawing.prototype.fill = function (x, y, newColor, _a) {\n    var tolerance = _a.tolerance;\n    newColor = this.toValidColor(newColor);\n\n    if (this.positions.length === 0 && !this.imageRestored) {\n      this.setBackground(newColor, false);\n      this.canvas.dispatchEvent(this.events.redrawEvent);\n      this.canvas.dispatchEvent(this.events.fillEvent);\n      return;\n    }\n\n    var pixels = this.width * this.height;\n    var imageData = this.context.getImageData(0, 0, this.width, this.height);\n    var newData = imageData.data;\n    var targetColor = this.getNodeColor(x, y, newData);\n    if (this.isNodeColorEqual(targetColor, newColor, tolerance)) return;\n    var queue = [];\n    queue.push([x, y]);\n\n    while (queue.length) {\n      if (queue.length > pixels) break;\n      var n = queue.pop();\n      var w = n;\n      var e = n;\n\n      while (this.isNodeColorEqual(this.getNodeColor(w[0] - 1, w[1], newData), targetColor, tolerance)) {\n        w = [w[0] - 1, w[1]];\n      }\n\n      while (this.isNodeColorEqual(this.getNodeColor(e[0] + 1, e[1], newData), targetColor, tolerance)) {\n        e = [e[0] + 1, e[1]];\n      }\n\n      var firstNode = w[0];\n      var lastNode = e[0];\n\n      for (var i = firstNode; i <= lastNode; i++) {\n        this.setNodeColor(i, w[1], newColor, newData);\n\n        if (this.isNodeColorEqual(this.getNodeColor(i, w[1] + 1, newData), targetColor, tolerance)) {\n          queue.push([i, w[1] + 1]);\n        }\n\n        if (this.isNodeColorEqual(this.getNodeColor(i, w[1] - 1, newData), targetColor, tolerance)) {\n          queue.push([i, w[1] - 1]);\n        }\n      }\n    }\n\n    this.context.putImageData(imageData, 0, 0);\n    this.canvas.dispatchEvent(this.events.redrawEvent);\n    this.canvas.dispatchEvent(this.events.fillEvent);\n  };\n\n  CanvasFreeDrawing.prototype.toValidColor = function (color) {\n    if (Array.isArray(color) && color.length === 4) color.pop();\n\n    if (Array.isArray(color) && color.length === 3) {\n      var validColor = color.slice();\n      validColor.push(255);\n      return validColor;\n    } else {\n      this.logWarning('Color is not valid!\\n' + 'It must be an array with RGB values:  [0-255, 0-255, 0-255]');\n      return [0, 0, 0, 255];\n    }\n  }; // i = color 1; j = color 2; t = tolerance\n\n\n  CanvasFreeDrawing.prototype.isNodeColorEqual = function (i, j, t) {\n    var color1 = '' + i[0] + i[1] + i[2] + i[3];\n    var color2 = '' + j[0] + j[1] + j[2] + j[3];\n    var key = color1 + color2 + t;\n    t = t || 0;\n\n    if (this.isNodeColorEqualCache.hasOwnProperty(color1 + color2 + t)) {\n      return this.isNodeColorEqualCache[key];\n    }\n\n    var diffRed = Math.abs(j[0] - i[0]);\n    var diffGreen = Math.abs(j[1] - i[1]);\n    var diffBlue = Math.abs(j[2] - i[2]);\n    var percentDiffRed = diffRed / 255;\n    var percentDiffGreen = diffGreen / 255;\n    var percentDiffBlue = diffBlue / 255;\n    var percentDiff = (percentDiffRed + percentDiffGreen + percentDiffBlue) / 3 * 100;\n    var result = t >= percentDiff;\n    this.isNodeColorEqualCache[key] = result;\n    return result;\n  };\n\n  CanvasFreeDrawing.prototype.getNodeColor = function (x, y, data) {\n    var i = (x + y * this.width) * 4;\n    return [data[i], data[i + 1], data[i + 2], data[i + 3]];\n  };\n\n  CanvasFreeDrawing.prototype.setNodeColor = function (x, y, color, data) {\n    var i = (x + y * this.width) * 4;\n    data[i] = color[0];\n    data[i + 1] = color[1];\n    data[i + 2] = color[2];\n    data[i + 3] = color[3];\n  };\n\n  CanvasFreeDrawing.prototype.rgbaFromArray = function (a) {\n    return \"rgba(\" + a[0] + \",\" + a[1] + \",\" + a[2] + \",\" + a[3] + \")\";\n  };\n\n  CanvasFreeDrawing.prototype.setDimensions = function () {\n    this.canvas.height = this.height;\n    this.canvas.width = this.width;\n  };\n\n  CanvasFreeDrawing.prototype.toggleCursor = function () {\n    this.canvas.style.cursor = this.isDrawingModeEnabled ? 'crosshair' : 'auto';\n  };\n\n  CanvasFreeDrawing.prototype.storeDrawing = function (x, y, moving) {\n    if (moving) {\n      var lastIndex = this.positions.length - 1;\n      this.positions[lastIndex].push({\n        x: x,\n        y: y,\n        moving: moving,\n        lineWidth: this.lineWidth,\n        strokeColor: this.strokeColor,\n        isBucket: false\n      });\n    } else {\n      this.positions.push([{\n        x: x,\n        y: y,\n        isBucket: false,\n        moving: moving,\n        lineWidth: this.lineWidth,\n        strokeColor: this.strokeColor\n      }]);\n    }\n  };\n\n  CanvasFreeDrawing.prototype.storeSnapshot = function () {\n    var imageData = this.getCanvasSnapshot();\n    this.snapshots.push(imageData);\n\n    if (this.snapshots.length > this.maxSnapshots) {\n      this.snapshots = this.snapshots.splice(-Math.abs(this.maxSnapshots));\n    }\n  };\n\n  CanvasFreeDrawing.prototype.getCanvasSnapshot = function () {\n    return this.context.getImageData(0, 0, this.width, this.height);\n  };\n\n  CanvasFreeDrawing.prototype.restoreCanvasSnapshot = function (imageData) {\n    this.context.putImageData(imageData, 0, 0);\n  }; // Public APIs\n\n\n  CanvasFreeDrawing.prototype.on = function (params, callback) {\n    var event = params.event,\n        counter = params.counter;\n    this.requiredParam(params, 'event');\n\n    if (this.allowedEvents.includes(event)) {\n      if (event === 'redraw' && counter && Number.isInteger(counter)) {\n        this.dispatchEventsOnceEvery = counter;\n      }\n\n      this.canvas.addEventListener('cfd_' + event, function () {\n        return callback();\n      });\n    } else {\n      this.logWarning(\"This event is not allowed: \" + event);\n    }\n  };\n\n  CanvasFreeDrawing.prototype.setLineWidth = function (px) {\n    this.lineWidth = px;\n  };\n\n  CanvasFreeDrawing.prototype.setBackground = function (color, save) {\n    if (save === void 0) {\n      save = true;\n    }\n\n    var validColor = this.toValidColor(color);\n\n    if (validColor) {\n      if (save) this.backgroundColor = validColor;\n      this.context.fillStyle = this.rgbaFromArray(validColor);\n      this.context.fillRect(0, 0, this.width, this.height);\n    }\n  };\n\n  CanvasFreeDrawing.prototype.setDrawingColor = function (color) {\n    this.configBucketTool({\n      color: color\n    });\n    this.setStrokeColor(color);\n  };\n\n  CanvasFreeDrawing.prototype.setStrokeColor = function (color) {\n    this.strokeColor = this.toValidColor(color);\n  };\n\n  CanvasFreeDrawing.prototype.configBucketTool = function (params) {\n    var _a = params.color,\n        color = _a === void 0 ? null : _a,\n        _b = params.tolerance,\n        tolerance = _b === void 0 ? null : _b;\n    if (color) this.bucketToolColor = this.toValidColor(color);\n\n    if (tolerance && tolerance > 0) {\n      this.bucketToolTolerance = tolerance > 100 ? 100 : tolerance;\n    }\n  };\n\n  CanvasFreeDrawing.prototype.toggleBucketTool = function () {\n    return this.isBucketToolEnabled = !this.isBucketToolEnabled;\n  };\n\n  CanvasFreeDrawing.prototype.toggleDrawingMode = function () {\n    return this.isDrawingModeEnabled ? this.disableDrawingMode() : this.enableDrawingMode();\n  };\n\n  CanvasFreeDrawing.prototype.clear = function () {\n    this.context.clearRect(0, 0, this.width, this.height);\n    this.positions = [];\n    this.imageRestored = false;\n    if (this.backgroundColor) this.setBackground(this.backgroundColor);\n    this.handleEndDrawing();\n  };\n\n  CanvasFreeDrawing.prototype.save = function () {\n    return this.canvas.toDataURL();\n  };\n\n  CanvasFreeDrawing.prototype.restore = function (backup, callback) {\n    var _this = this;\n\n    var image = new Image();\n    image.src = backup;\n\n    image.onload = function () {\n      _this.imageRestored = true;\n\n      _this.context.drawImage(image, 0, 0);\n\n      if (typeof callback === 'function') callback();\n    };\n  };\n\n  CanvasFreeDrawing.prototype.undo = function () {\n    var lastSnapshot = this.snapshots[this.snapshots.length - 1];\n    var goToSnapshot = this.snapshots[this.snapshots.length - 2];\n\n    if (goToSnapshot) {\n      this.restoreCanvasSnapshot(goToSnapshot);\n      this.snapshots.pop();\n      this.undos.push(lastSnapshot);\n      this.undos = this.undos.splice(-Math.abs(this.maxSnapshots));\n      this.imageRestored = true;\n    } else {\n      this.logWarning('There are no more undos left.');\n    }\n  };\n\n  CanvasFreeDrawing.prototype.redo = function () {\n    if (this.undos.length > 0) {\n      var lastUndo = this.undos.pop();\n\n      if (lastUndo) {\n        this.restoreCanvasSnapshot(lastUndo);\n        this.snapshots.push(lastUndo);\n        this.snapshots = this.snapshots.splice(-Math.abs(this.maxSnapshots));\n      }\n    } else {\n      this.logWarning('There are no more redo left.');\n    }\n  };\n\n  return CanvasFreeDrawing;\n}();\n\nexports.default = CanvasFreeDrawing;","map":null,"metadata":{},"sourceType":"script"}